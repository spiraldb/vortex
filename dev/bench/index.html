<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes"/>
    <link rel="icon" type="image/x-icon" href="favicon.png">
    <style>
        html {
            font-family: BlinkMacSystemFont, -apple-system, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
            -webkit-font-smoothing: antialiased;
            background-color: #fff;
            font-size: 16px;
        }

        body {
            color: #4a4a4a;
            margin: 8px;
            font-size: 1em;
            font-weight: 400;
        }

        header {
            margin-bottom: 8px;
            display: flex;
            flex-direction: column;
        }

        main {
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        a {
            color: #3273dc;
            cursor: pointer;
            text-decoration: none;
        }

        a:hover {
            color: #000;
        }

        button {
            color: #fff;
            background-color: #3298dc;
            border-color: transparent;
            cursor: pointer;
            text-align: center;
        }

        button:hover {
            background-color: #2793da;
            flex: none;
        }

        .spacer {
            flex: auto;
        }

        .small {
            font-size: 0.75rem;
        }

        footer {
            margin-top: 16px;
            display: flex;
            align-items: center;
        }

        .header-label {
            margin-right: 4px;
        }

        .benchmark-set {
            margin: 8px 0;
            width: 100%;
            display: flex;
            flex-direction: column;
        }

        .benchmark-title {
            font-size: 3rem;
            font-weight: 600;
            word-break: break-word;
            text-align: center;
        }

        .benchmark-graphs {
            display: flex;
            flex-direction: row;
            justify-content: space-around;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
        }

        .benchmark-chart {
            max-width: 550px;
            max-height: 600px;
        }
    </style>
    <title>Benchmarks</title>
</head>

<body>
<header id="header">
    <div class="header-item">
        <strong class="header-label">Last Update:</strong>
        <span id="last-update"></span>
    </div>
    <div class="header-item">
        <strong class="header-label">Repository:</strong>
        <a id="repository-link" rel="noopener"></a>
    </div>
</header>
<main id="main"></main>
<footer>
    <button id="dl-button">Download data as JSON</button>
    <div class="spacer"></div>
    <div class="small">Powered by <a rel="noopener" href="https://github.com/marketplace/actions/continuous-benchmark">github-action-benchmark</a>
    </div>
</footer>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<script src="https://cdn.rawgit.com/h2non/jsHashes/master/hashes.js"></script>
<!-- Chart.js Zoom Plugin -->
<script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
<!-- Chart.js Zoom Plugin -->

<script src="data.js"></script>
<script id="main-script">
    'use strict';
    (function () {
        function stringToColor(str) {
            // Random colours are generally pretty disgusting...
            const MAP = {
                "vortex-file-uncompressed": '#98da8d',
                "vortex-file-compressed": '#23d100',
                "vortex-in-memory-no-pushdown": '#79a6df',
                "vortex-in-memory-pushdown": '#0c53ae',
                "arrow": '#58067e',
                "parquet": '#ef7f1d',
            };

            if (MAP[str]) {
                return MAP[str];
            } else {
                console.log("Using random color for: " + str)
            }

            var hash = new Hashes.MD5().hex(str)

            // Return a CSS color string
            const hexColor = hash.slice(0, 2) + hash.slice(14, 16) + hash.slice(30, 32);
            return `#${hexColor}`;
        }

        function init() {
            function collectBenchesPerTestCase(entries) {
                // It's desirable for all our graphs to line up in terms of X-axis.
                // As such, we collect all unique {commit,entry} first, and then assign
                // data points to them for each graph. Commits are sorted by date.
                const commits = [];
                const dates = [];
                entries.sort((a, b) => new Date(a.commit.timestamp) - new Date(b.commit.timestamp)).forEach(entry => {
                    commits.push(entry.commit);
                    dates.push(entry.date);
                });


                const map = new Map();
                entries.forEach((entry, entryIdx) => {
                    const {tool, benches} = entry;

                    for (const bench of benches) {
                        const {name, range, unit, value} = bench;
                        const is_nanos = unit === "ns/iter";
                        // Normalize name
                        let [q, seriesName] = name.split("/");
                        let prettyQ = q.replace("_", " ").toUpperCase();
                        let query_idx = parseInt(prettyQ.split(" ")[1].substring(1), 10);

                        let arr = map.get(prettyQ);
                        if (arr === undefined) {
                            map.set(prettyQ, {
                                query_idx,
                                commits,
                                unit: is_nanos ? "ms/iter" : unit,
                                series: new Map(),
                            });
                            arr = map.get(prettyQ);
                        }

                        let series = arr.series.get(seriesName);
                        if (series === undefined) {
                            arr.series.set(seriesName, new Array(entries.length).fill(null));
                            series = arr.series.get(seriesName);
                        }
                        series[entryIdx] = {range, value: is_nanos ? value / 1_000_000 : value};
                    }
                });
                return new Map([...map.entries()].sort((a, b) => a[1].query_idx - b[1].query_idx));
            }

            const data = window.BENCHMARK_DATA;

            // Render header
            document.getElementById('last-update').textContent = new Date(data.lastUpdate).toString();
            const repoLink = document.getElementById('repository-link');
            repoLink.href = data.repoUrl;
            repoLink.textContent = data.repoUrl;

            // Render footer
            document.getElementById('dl-button').onclick = () => {
                const dataUrl = 'data:,' + JSON.stringify(data, null, 2);
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = 'benchmark_data.json';
                a.click();
            };

            // Prepare data points for charts
            return Object.keys(data.entries).map(name => ({
                name,
                dataSet: collectBenchesPerTestCase(data.entries[name]),
            }));
        }

        function renderAllChars(dataSets) {

            var charts = [];

            function renderGraph(parent, name, dataset) {
                const canvas = document.createElement('canvas');
                canvas.className = 'benchmark-chart';
                parent.appendChild(canvas);

                const data = {
                    labels: dataset.commits.map(commit => commit.id.slice(0, 7)),
                    datasets: Array.from(dataset.series).map(([name, benches]) => {
                        const color = stringToColor(name);
                        return {
                            label: name,
                            data: benches.map(b => b ? b.value : null),
                            borderColor: color,
                            backgroundColor: color + '60', // Add alpha for #rrggbbaa
                        };
                    }),
                };
                const options = {
                    spanGaps: true,
                    pointStyle: 'crossRot',
                    elements: {
                        line: {
                            borderWidth: 1,
                        },
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: name,
                                padding: {bottom: 50},
                            },
                            // By default, show the last 50 commits
                            min: Math.max(0, dataset.commits.length - 50),
                        },
                        y: {
                            title: {
                                display: true,
                                text: dataset.commits.length > 0 ? dataset.unit : '',
                            },
                            suggestedMin: 0,
                        },
                    },
                    tooltips: {
                        callbacks: {
                            afterTitle: items => {
                                const {index} = items[0];
                                const commit = dataset.commits[index];
                                return '\n' + commit.message + '\n\n' + commit.timestamp + ' committed by @' + commit.committer.username + '\n';
                            },
                            label: item => {
                                const seriesName = Array.from(dataset.series.keys())[item.datasetIndex];
                                let label = item.value;
                                const {range, unit} = dataset.series.get(seriesName)[item.index];
                                label += ' ' + unit;
                                if (range) {
                                    label += ' (' + range + ')';
                                }
                                return label;
                            },
                            afterLabel: item => {
                                const seriesName = Array.from(dataset.series.keys())[item.datasetIndex];
                                const {extra} = dataset.series.get(seriesName)[item.index];
                                return extra ? '\n' + extra : '';
                            }
                        }
                    },
                    plugins: {
                        zoom: {
                            zoom: {
                                wheel: {enabled: true},
                                mode: 'x',
                                drag: {enabled: true}
                            }
                        },
                        legend: {
                            display: true,
                            onClick: function (e, legendItem) {
                                var index = legendItem.datasetIndex;

                                var wasVisible = this.chart.isDatasetVisible(index);
                                var datasetLabel = this.chart.data.datasets[index].label;
                                var clickedChart = this.chart;

                                charts.forEach(function(chart) {
                                    chart.data.datasets.forEach(function(ds, idx) {
                                        if (ds.label === datasetLabel) {
                                            chart.getDatasetMeta(idx).hidden = wasVisible;
                                        }
                                    });

                                    chart.update();
                                });
                            }
                        }
                    },
                    onClick: (_mouseEvent, activeElems) => {
                        if (activeElems.length === 0) {
                            return;
                        }
                        // XXX: Undocumented. How can we know the index?
                        const index = activeElems[0]._index;
                        const url = dataset[index].commit.url;
                        window.open(url, '_blank');
                    },
                };

                return new Chart(canvas, {
                    type: 'line',
                    data,
                    options,
                });
            }

            function renderBenchSet(name, benchSet, main) {
                const setElem = document.createElement('div');
                setElem.className = 'benchmark-set';
                main.appendChild(setElem);

                const nameElem = document.createElement('h1');
                nameElem.className = 'benchmark-title';
                nameElem.textContent = name;
                setElem.appendChild(nameElem);

                const graphsElem = document.createElement('div');
                graphsElem.className = 'benchmark-graphs';
                setElem.appendChild(graphsElem);

                for (const [benchName, benches] of benchSet.entries()) {
                    charts.push(renderGraph(graphsElem, benchName, benches))
                }
            }

            const main = document.getElementById('main');
            for (const {name, dataSet} of dataSets) {
                renderBenchSet(name, dataSet, main);
            }
        }

        renderAllChars(init()); // Start
    })();
</script>
</body>
</html>
